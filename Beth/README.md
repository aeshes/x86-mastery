# Таблица опкодов инструкций

| Опкод    | Мнемоника             | Описание
| -------- | :-------------------- |:----------
| **B8h**  | mov регистр, значение | Сохранить число в регистре общего назначения
| **8Bh**  | mov регистр, регистр  | Очевидно

### Инструкция mov
```
db 0B8h ; mov eax, 17
dd 17
```
32-битное число `17` вставлено при помощи инструкции определения двойного слова `dd`, а в результате это будет последовательность байт `17, 0, 0, 0`. В архитектуре процессоров x86 байты слов и двойных слов распогалаются от младшего к старшему, поэтому байт 17 находится в самом начале - в младшем байте. Вышеприведенное можно записать так:
```
; mov eax, 17
db 0B8h, 11h, 00h, 00h, 00h
```

Чтобы сохранить значение в другом регистре общего назначения, надо прибавить к базовому опкоду mov (**B8h**) номер этого регистра:

```
mov edi, 1
Номер EDI - 7
0B8h + 7 = 0BFh
```

### ModR/M

Байт `Mod-Reg-R/M` следует за опкодом и определяет операнды инструкции и режим адресации. Структура ModRM-байта:

![Mod-Reg-R/m](https://github.com/aeshes/x86-mastery/blob/master/Beth/img/mod_reg_r_m_byte.png)

Поле **Mod** состоит из двух бит и определяет режим адресации. Значение `11b` задает режим регистровой адресации. Поле **R/M** в сочетании с **Mod** задает либо второй операнд инструкции, либо единственный операнд инструкции типа **NOT** или **NEG**.

Сформируем инструкцию mov edx, eax по этому принципу. Базовый опкод `mov регистр, регистр` - **8Bh**, режим адресации `Mod=11b` задает регистровую адресацию. `Reg` и `R/M` служат для указания операндов: в `Reg` номер первого регистра, в `R/M` - номер второго. Получаем:

```
Базовый опкод: 8Bh
Mod = 11b
Reg = 010b ; ecx
R/M = 000b ; eax
Получили инструкцию: db 8Bh, 11010000b ; 8Bh (опкод) 11 (адресация) 010 (ecx) 000 (eax)
```