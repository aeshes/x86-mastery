# Таблица опкодов инструкций

| Опкод    | Мнемоника             | Описание
| -------- | :-------------------- |:----------
| **B8h**  | mov регистр, значение | Сохранить число в регистре общего назначения
| **8Bh**  | mov регистр, регистр  | Очевидно
| **03h**  | add регистр, регистр  |
| **68h**  | push число            | push 50 - пример
| **81h**  | add регистр, число    | add esp, 8 - пример

### Инструкция mov
```
db 0B8h ; mov eax, 17
dd 17
```
32-битное число `17` вставлено при помощи инструкции определения двойного слова `dd`, а в результате это будет последовательность байт `17, 0, 0, 0`. В архитектуре процессоров x86 байты слов и двойных слов распогалаются от младшего к старшему, поэтому байт 17 находится в самом начале - в младшем байте. Вышеприведенное можно записать так:
```
; mov eax, 17
db 0B8h, 11h, 00h, 00h, 00h
```

Чтобы сохранить значение в другом регистре общего назначения, надо прибавить к базовому опкоду mov (**B8h**) номер этого регистра:

```
mov edi, 1
Номер EDI - 7
0B8h + 7 = 0BFh
```

### ModR/M

Байт `Mod-Reg-R/M` следует за опкодом и определяет операнды инструкции и режим адресации. Структура ModRM-байта:

![Mod-Reg-R/m](https://github.com/aeshes/x86-mastery/blob/master/Beth/img/mod_reg_r_m_byte.png)

Поле **Mod** состоит из двух бит и определяет режим адресации. Значение `11b` задает режим регистровой адресации. Поле **R/M** в сочетании с **Mod** задает либо второй операнд инструкции, либо единственный операнд инструкции типа **NOT** или **NEG**. Другими словами, `Mod` определяет, что именно кодируется в `R/M`.

Сформируем инструкцию mov edx, eax по этому принципу. Базовый опкод `mov регистр, регистр` - **8Bh**, режим адресации `Mod=11b` задает регистровую адресацию. `Reg` и `R/M` служат для указания операндов: в `Reg` номер первого регистра, в `R/M` - номер второго. Получаем:

```
Базовый опкод: 8Bh
Mod = 11b
Reg = 010b ; edx
R/M = 000b ; eax
Получили инструкцию: db 8Bh, 11010000b ; 8Bh (опкод) 11 (адресация, mod) 010 (reg=edx) 000 (r/m=eax)
```

### Инструкция add регистр, регистр

Теперь рассмотрим инструкцию `add регистр, регистр`. Ее базовый опкод `03h` и она повинуется указанному правилу, поэтому мы легко можем составить заклинание `add eax, ecx`:

```
db 03h, 11000001b ; 
Здесь опкод = 03h, ModR/M = 11 (mod = регистровая адресация) 000 (reg = eax) 001 (r/m = ecx)
```

### Инструкция add регистр, число

add esp, 8 создать несложно. Однако для этой инструкции не применимы правила, описанные выше, потому что операндами здесь выступают не два регистра, а один регистр и число-константа. Задача решается просто: в `Reg` записываем 0, а в `R/M` - номер регистра. В `Mod` записываем `11b`, а число располагается непосредственно после байт опкода и `ModR/M`. В итоге получаем:

```
Формируем add esp, 8
Опкод: 81h
ModR/M: Mod = 11b, Reg = 000b, R/M = 100b
Число: 8
Результат: db 81h, 11000100b
           dd 8
```